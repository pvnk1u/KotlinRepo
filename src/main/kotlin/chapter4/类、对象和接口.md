# 类、对象和接口
`Kotlin`的类和接口与`Java`的类和接口还是有去别的。例如，接口可以包含属性声明。与`Java`不同，`Kotlin`的声明默认是`final`和`public`的。此外，嵌套的类默认并不是内部类：它们并没有包含对其外部类的隐式引用。

对于构造方法来说，简短的主构造方法语法在大多数情况下都工作得很好，但是依然有完整的语法可以声明带有重要初始化逻辑的构造方法。对于属性也是一样的：简洁的语法非常好用，但是还是可以方便地定义自己的访问器实现。

`Kotlin`编译器能够生成有用的方法来避免冗余。将一个类声明为`data`类可以让编译器为这个类生成若干标准方法。同样可以避免动手书写委托方法，因为委托模式是`Kotlin`原生支持的。

## 定义类继承机构
### Kotlin中的接口
`Kotlin`的接口和`Java`8中的相似：它们可以包含抽象方法的定义以及非抽象方法的实现（与Java8中的默认方法类似），但它们不能包含任何状态。

使用`interface`关键字而不是`class`来声明一个`Kotlin`的接口。
```kotlin
interface Clickable{
    fun click()
}
```

`Kotlin`在类名后面使用冒号来代替了`Java`中的`extends`和`implements`关键字。和`Java`一样，一个类可以实现多个接口，但是只能继承一个类。

与`Java`中的`@Override`注解类似，`override`修饰符用来标注被重写的父类或者接口的方法和属性。与`Java`不同的是，在`Kotlin`中使用`override`修饰符是强制要求的。这会避免先写出实现方法再添加抽象方法造成的意外重写：代码将不能编译，除非显式地将这个方法标注为`override`或者重命名它。

接口的方法可以有一个默认实现。与`Java8`不同的是，`Java8`中需要在这样的实现上标注`default`关键字，对于这样的方法，`Kotlin`没有特殊的注解：只需要提供一个方法体。下面给`Clickable`接口添加一个带默认实现的方法：
```kotlin
interface Clickable{
    // 普通的方法声明
    fun click()
    // 带默认实现的方法
    fun showOff() = println("I`m clickable!")
}
```

如果实现了这个接口，需要为`click`提供一个实现。可以重新定义`showOff`方法的行为，或者如果对默认行为感到满意也可以直接省略它。


假设存在同样定义了一个`showOff`方法并且有如下实现的另一个接口：
```kotlin
interface Focusable {

    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"}")

    fun showOff() = println("I`m focusable!")
}
```

如果需要在自己的class类中实现这两个接口会发生什么？它们每一个都包含了带默认实现的`showOff`方法，将会使用哪一个实现？答案是，任何一个都不会使用。取而代之的是，如果没有显式实现`showOff`，会出现编译错误。

在显式实现的方法里，如果想要调用实现多个接口中的某个默认实现方法时，可以使用`super`关键字实现：
```kotlin
class Button : Clickable,Focusable {

    override fun click() = println("I was clicked")

    override fun showOff(){
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

