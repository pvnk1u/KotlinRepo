# 类、对象和接口
`Kotlin`的类和接口与`Java`的类和接口还是有去别的。例如，接口可以包含属性声明。与`Java`不同，`Kotlin`的声明默认是`final`和`public`的。此外，嵌套的类默认并不是内部类：它们并没有包含对其外部类的隐式引用。

对于构造方法来说，简短的主构造方法语法在大多数情况下都工作得很好，但是依然有完整的语法可以声明带有重要初始化逻辑的构造方法。对于属性也是一样的：简洁的语法非常好用，但是还是可以方便地定义自己的访问器实现。

`Kotlin`编译器能够生成有用的方法来避免冗余。将一个类声明为`data`类可以让编译器为这个类生成若干标准方法。同样可以避免动手书写委托方法，因为委托模式是`Kotlin`原生支持的。

## 定义类继承机构
### Kotlin中的接口
`Kotlin`的接口和`Java`8中的相似：它们可以包含抽象方法的定义以及非抽象方法的实现（与Java8中的默认方法类似），但它们不能包含任何状态。

使用`interface`关键字而不是`class`来声明一个`Kotlin`的接口。
```kotlin
interface Clickable{
    fun click()
}
```

`Kotlin`在类名后面使用冒号来代替了`Java`中的`extends`和`implements`关键字。和`Java`一样，一个类可以实现多个接口，但是只能继承一个类。

与`Java`中的`@Override`注解类似，`override`修饰符用来标注被重写的父类或者接口的方法和属性。与`Java`不同的是，在`Kotlin`中使用`override`修饰符是强制要求的。这会避免先写出实现方法再添加抽象方法造成的意外重写：代码将不能编译，除非显式地将这个方法标注为`override`或者重命名它。

接口的方法可以有一个默认实现。与`Java8`不同的是，`Java8`中需要在这样的实现上标注`default`关键字，对于这样的方法，`Kotlin`没有特殊的注解：只需要提供一个方法体。下面给`Clickable`接口添加一个带默认实现的方法：
```kotlin
interface Clickable{
    // 普通的方法声明
    fun click()
    // 带默认实现的方法
    fun showOff() = println("I`m clickable!")
}
```

如果实现了这个接口，需要为`click`提供一个实现。可以重新定义`showOff`方法的行为，或者如果对默认行为感到满意也可以直接省略它。


假设存在同样定义了一个`showOff`方法并且有如下实现的另一个接口：
```kotlin
interface Focusable {

    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"}")

    fun showOff() = println("I`m focusable!")
}
```

如果需要在自己的class类中实现这两个接口会发生什么？它们每一个都包含了带默认实现的`showOff`方法，将会使用哪一个实现？答案是，任何一个都不会使用。取而代之的是，如果没有显式实现`showOff`，会出现编译错误。

在显式实现的方法里，如果想要调用实现多个接口中的某个默认实现方法时，可以使用`super`关键字实现：
```kotlin
class Button : Clickable,Focusable {

    override fun click() = println("I was clicked")

    override fun showOff(){
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

### open、final和abstract修饰符：默认为final
`Java`允许创建任意类的子类并重写任意方法，除非显式地使用了`final`关键字进行标注。这通常很方便，但也造成了一些问题。

对基类进行修改会导致不正确的行为，这就是所谓的脆弱的基类问题，因为基类代码的修改不再符合在其子类中的假设。如果类没有提供子类应该怎么实现的明确规则（哪些方法需要被重写及如何重写），当事人可能会有按基类作者预期之外的方式来重写方法的危险。因为不可能分析所有的子类，这种情况下基类是如此“脆弱”，任何修改都有可能导致子类出现预期之外的行为改变。

为了防止这种问题，`Effective Java`建议“要么为继承做好设计并记录文档，要么禁止这么做”。这意味着所有没有特别需要在子类中被重写的类和方法应该被显式地标注为`final`。

`Kotlin`采用了同样地哲学思想。`Java`的类和方法默认是`open`的，而`Kotlin`中默认都是`final`的。

`如果想允许创建一个类的子类，需要使用`open`修饰符来标识这个类。此外，需要给每一个可以被重写的属性或方法添加`open`修饰符。`


```kotlin

//  这个类是open的：其他类可以继承它
open class RichButton :Clickable {

    // 这个函数是final的：不能在子类中重写它
    fun disable(){}

    // 这个函数是open的：可以在子类中重写它
    open fun animate(){}

    // 这个函数重写了一个open函数并且它本身同样是open的
    override fun click(){}
}
```

注意，如果重写了一个基类或者接口的成员，重写了的成员同样默认是`open`的。如果想改变这一行为，阻止类的子类重写实现，可以显式地将重写的成员标注为`final`。
```kotlin
open class RichButton: Clickable{
    /**
     * *
     在这里final并没有被删减是因为没有final的override意味着是open的
     */
    final override fun click(){}
}
```

在`Kotlin`中，同`Java`一样，可以将一个类声明为`abstract`的，这种类不能被实例化。一个抽象类通常包含一些没有实现并且必须在子类重写的抽象成员。抽象成员始终是`open`的，所以不需要显式地使用`open`修饰符。接下来是示例：
```kotlin
// 这个类是抽象的：不能创建它的实例
abstract class Animated{
    
    // 这个函数是抽象的：它没有实现必须被子类重写
    abstract fun animate()
    
    // 抽象类中的非抽象函数并不是默认open的，但是可以标注为open的
    open fun stopAnimating(){
        
    }
    
    fun animateTwice(){
        
    }
    
}
```

### 可见性修饰符：默认为public
总的来说，`Kotlin`中的可见性修饰符与`Java`中的类似。同样可以使用`public`、`protected`和`private`修饰符。但是默认的可见性是不一样的：如果省略了修饰符，声明就是`public`的。

`Java`中的默认可见性——`包私有`，在`kotlin`中并没有被使用。`Kotlin`只把包作为在命名空间里组织代码的一种方式使用，并没有将其作可见性控制。也就是说，`Kotlin`中的`protected`成员只在类和它的子类中可见。

作为替代方案，`Kotlin`提供了一个新的修饰符，`internal`，表示“只在模块内部可见”。一个模块就是一组一起编译的`Kotlin`文件。这有可能是一个`IDEA`模块、一个`Eclipse`项目、一个`Maven`或`Gradle`项目或者一组使用调用`Ant`任务进行编译的文件。

`internal`可见性的优势在于它提供了对模块实现细节的真正封装。使用`Java`时，这种封装很容易被破坏，因为外部代码可以将类定义到与代码相同的包中，从而得到访问包私有声明的权限。

另一个区别就是`Kotlin`允许在顶层声明中使用`private`可见性，包括类、函数和属性。这些声明就会只在声明它们的文件中可见。


### 内部类和嵌套类：默认是嵌套类
像`Java`一样，在`Kotlin`中可以在一个类中声明另一个类。这样做在封装一个辅助类或者把一些代码放到靠近它被使用的地方时非常有用。区别是`Kotlin`的嵌套类不能访问外部类的实例，除非特别地做出了要求。

设想一下需要定义一个`View`元素，它的状态是可以序列化的。想要序列化一个视图可能并不容易，但是可以把所有需要的数据复制到另一个辅助类中去。声明了`State`接口去实现`Serializable`。`View`接口声明了可以用来保存视图状态的`getCurrentState`和`restoreState`方法。

```kotlin
import java.io.Serializable

interface State: Serializable {
}

interface View{
    fun getCurrentState(): State

    fun restoreState(state: State){}
}

```

可以方便地定义一个保存按钮状态的`Button`类，先来看看在`Java`中是怎么做的：
```java
public class JavaButton implements View{

    @Override
    public State getCurrentState() {
        return new ButtonState();
    }

    @Override
    public void restoreState(State state) {

    }

    public class ButtonState implements State{

    }
}
```
可以看到，定义了实现`State`接口的`ButtonState`类，并且持有`Button`的特定信息。在`getCurrentState`方法中，创建了这个类的一个新的实例。在真实情况下，需要使用所有需要的数据来初始化`ButtonState`。
这段代码有什么问题？会得到一个`java.io.NotSerializableException:Button`异常，这最开始可能会看起来很奇怪：序列化的变量是`ButtonState`类型的`state`，并不是`Button`类型。但是当想起来这是在`Java`中时所有的事情都清楚了，**当在另一个类中声明一个类时，它会默认变成内部类。**这个例子中的`ButtonState`类隐式地存储了它的外部`Button`类的引用。这就解释了为什么`ButtonState`不能被序列化：`Button`不是可序列化的，并且它的引用破坏了`ButtonState`的序列化。
要修复这个问题，需要声明`ButtonState`类是`static`的。将一个嵌套类声明为`static`会从这个类中删除包围它的类的隐式引用。

在`Kotlin`中，内部类的默认行为与刚刚描述的是相反的，就像接下来的例子：
```kotlin

class Button : View {

    override fun getCurrentState(): State = ButtonState()

    override fun restoreState(state: State) {
        super.restoreState(state)
    }

    // 与Java中的静态嵌套类类似
    class ButtonState: State{

    }
}
```

**`Kotlin`中没有显式修饰符的嵌套类与`Java`中的`static`嵌套类是一样的。要把它变成一个内部类来持有一个外部类的引用的话需要使用`inner`修饰符。**

在`Kotlin`中引用外部类实例的语法也与`Java`不同。需要使用`this@Outer`从`Inner`去访问`Outer`类：
```kotlin
class Outer{
    inner class Inner{
        fun getOuterReference(): Outer = this@Outer
    }
}
```

学习了`Java`和`Kotlin`中内部类和嵌套类的区别后，再来讨论另一个可能在`Kotlin`中很有用的嵌套类使用场景：创建一个包含有限数量的继承结构。

### 密封类：定义受限的类继承结构
