# 类、对象和接口
`Kotlin`的类和接口与`Java`的类和接口还是有去别的。例如，接口可以包含属性声明。与`Java`不同，`Kotlin`的声明默认是`final`和`public`的。此外，嵌套的类默认并不是内部类：它们并没有包含对其外部类的隐式引用。

对于构造方法来说，简短的主构造方法语法在大多数情况下都工作得很好，但是依然有完整的语法可以声明带有重要初始化逻辑的构造方法。对于属性也是一样的：简洁的语法非常好用，但是还是可以方便地定义自己的访问器实现。

`Kotlin`编译器能够生成有用的方法来避免冗余。将一个类声明为`data`类可以让编译器为这个类生成若干标准方法。同样可以避免动手书写委托方法，因为委托模式是`Kotlin`原生支持的。

## 定义类继承机构
### Kotlin中的接口
`Kotlin`的接口和`Java`8中的相似：它们可以包含抽象方法的定义以及非抽象方法的实现（与Java8中的默认方法类似），但它们不能包含任何状态。

使用`interface`关键字而不是`class`来声明一个`Kotlin`的接口。
```kotlin
interface Clickable{
    fun click()
}
```

`Kotlin`在类名后面使用冒号来代替了`Java`中的`extends`和`implements`关键字。和`Java`一样，一个类可以实现多个接口，但是只能继承一个类。

与`Java`中的`@Override`注解类似，`override`修饰符用来标注被重写的父类或者接口的方法和属性。与`Java`不同的是，在`Kotlin`中使用`override`修饰符是强制要求的。这会避免先写出实现方法再添加抽象方法造成的意外重写：代码将不能编译，除非显式地将这个方法标注为`override`或者重命名它。

接口的方法可以有一个默认实现。与`Java8`不同的是，`Java8`中需要在这样的实现上标注`default`关键字，对于这样的方法，`Kotlin`没有特殊的注解：只需要提供一个方法体。下面给`Clickable`接口添加一个带默认实现的方法：
```kotlin
interface Clickable{
    // 普通的方法声明
    fun click()
    // 带默认实现的方法
    fun showOff() = println("I`m clickable!")
}
```

如果实现了这个接口，需要为`click`提供一个实现。可以重新定义`showOff`方法的行为，或者如果对默认行为感到满意也可以直接省略它。


假设存在同样定义了一个`showOff`方法并且有如下实现的另一个接口：
```kotlin
interface Focusable {

    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"}")

    fun showOff() = println("I`m focusable!")
}
```

如果需要在自己的class类中实现这两个接口会发生什么？它们每一个都包含了带默认实现的`showOff`方法，将会使用哪一个实现？答案是，任何一个都不会使用。取而代之的是，如果没有显式实现`showOff`，会出现编译错误。

在显式实现的方法里，如果想要调用实现多个接口中的某个默认实现方法时，可以使用`super`关键字实现：
```kotlin
class Button : Clickable,Focusable {

    override fun click() = println("I was clicked")

    override fun showOff(){
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

### open、final和abstract修饰符：默认为final
`Java`允许创建任意类的子类并重写任意方法，除非显式地使用了`final`关键字进行标注。这通常很方便，但也造成了一些问题。

对基类进行修改会导致不正确的行为，这就是所谓的脆弱的基类问题，因为基类代码的修改不再符合在其子类中的假设。如果类没有提供子类应该怎么实现的明确规则（哪些方法需要被重写及如何重写），当事人可能会有按基类作者预期之外的方式来重写方法的危险。因为不可能分析所有的子类，这种情况下基类是如此“脆弱”，任何修改都有可能导致子类出现预期之外的行为改变。

为了防止这种问题，`Effective Java`建议“要么为继承做好设计并记录文档，要么禁止这么做”。这意味着所有没有特别需要在子类中被重写的类和方法应该被显式地标注为`final`。

`Kotlin`采用了同样地哲学思想。`Java`的类和方法默认是`open`的，而`Kotlin`中默认都是`final`的。

`如果想允许创建一个类的子类，需要使用`open`修饰符来标识这个类。此外，需要给每一个可以被重写的属性或方法添加`open`修饰符。`


```kotlin

//  这个类是open的：其他类可以继承它
open class RichButton :Clickable {

    // 这个函数是final的：不能在子类中重写它
    fun disable(){}

    // 这个函数是open的：可以在子类中重写它
    open fun animate(){}

    // 这个函数重写了一个open函数并且它本身同样是open的
    override fun click(){}
}
```

注意，如果重写了一个基类或者接口的成员，重写了的成员同样默认是`open`的。如果想改变这一行为，阻止类的子类重写实现，可以显式地将重写的成员标注为`final`。