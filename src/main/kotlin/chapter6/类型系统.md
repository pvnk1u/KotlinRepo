与`Java`相比，`Kotlin`在类型系统中引入了一些新特性，它们是提升代码可读性的基本要素，比如：对可空的类型和只读集合的支持。与此同时，`Kotlin`去掉了一些`Java`类型系统中不必要的或者有问题的特性，比如把数组当作头等公民来支持。



# 可空性

可空性是`Kotlin`类型系统中帮助避免`NullPointerException`错误的特性。



现代编程语言包括`Kotlin`解决这类问题的方法是把运行时的错误转变为编译期的错误。通过支持作为类型系统的一部分的可空性，编译器就能在编译器发现很多潜在的错误，从而减少运行时抛出异常的可能性。



## 可空类型

`Kotlin`和`Java`的类型系统之间第一条也可能是最重要的一条区别是，`Kotlin`对可空类型的显式的支持。这是一种指出程序中哪些变量和属性允许为`null`的方式。如果一个变量可以为`null`，对变量的方法的调用就是不安全的，因为这样会导致`NPE`。`Kotlin`不允许这样的调用，因而可以阻止许多可能的异常。



先看下面的`Java`函数：

```java
/* Java */
int strLen(String s){
	return s.length();
}
```

如果这个函数被调用的时候，传给它的是一个`null`实参，它就会抛出`NPE`。



接下来试着用`Kotlin`重写这个函数。第一个必须回答的问题是，期望这个函数被调用的时候传给它的实参可以为`null`吗？无论是语句`strLen(null)`中这样直接的字面值`null`，还是任何在运行时可能为`null`的变量或者表达式。



如果不期望这种情况发生，在`Kotlin`中要像下面这样声明这个函数：

```kotlin
fun strLen(s:String) = s.length
```

使用可能为`null`的实参调用`strLen`是不允许的，在编译期就会被标记成错误：

```kotlin
strLen(null)
// NPE
```

如果允许调用这个方法的时候传给它所有可能的实参，包括那些可以为`null`的实参，需要显式地在类型名称后面加上问号来标记它：

```kotlin
fun strLenSafe(s: String?) = ...
```

问号可以加在任何类型的后面来表示这个类型的变量可以存储`null`引用：`String?`、`Int?`等等。



一旦有一个可空类型的值，能对它进行的操作也会受到限制。例如，不能再调用它的方法：

```kotlin
>>> fun strLenSafe(s: String? ) = s.length()
ERROR only safe (?.) or non-null asserted (!!.) calls are allowed 
	on a nullable receiver of type kotlin.String?
```

也不能把它赋值给非空类型的变量：

```kotlin
>>> val x: String? = null
>>> var y: String = x
ERROR: Type mismatch: inferred type is String? but String was expected
```

也不能把可空类型的值传给拥有非空类型参数的函数：

```kotlin
>>> strLen(x)
ERROR: Type mismatch: inferred type is String? but String was expected
```

那么可以对它做什么呢？最重要的操作就是和`null`进行比较。而且一旦进行了比较操作，编译器就会记住，并且在这次发生比较的作用域内把这个值当作非空来对待。例如，下面这段代码是完全合法的：

```kotlin
fun strLenSafe(s: String?): Int =
    if (s != null) s.length else 0

fun main(args:Array<String>){
    val  x:String? = null
    println(strLenSafe(x))
    // 0
    println(strLenSafe("abd"))
    // 3
}
```

如果`if`检查只是唯一处理可空性的工具，代码很快将会变得冗长。幸运的是，`Kotlin`还提供了其他一些工具来用更简洁的方式来处理可空值。在了解这些工具之前。需要先花些时间讨论一下可空性的含义，以及什么是变量类型。



## 类型的含义

先思考一下最普遍的问题：什么是类型，为什么变量拥有类型？维基百科给出了答案：“类型就是数据的分类...决定了该类型可能的值”，以及该类型的值上可以完成的操作。



试试在`Java`的一些类型上套用这个定义，先从`double`类型开始 。`double` 是 64 位的双精度浮点数。可以对 `double` 类型的值进行标准的算术运算，所有的功能都可以一视同仁地运用到所有`double`类型的值上 。因此，如果你有一个类型为`double`的变量，那么你就能确定编译器允许的该变量值上的任何操作，都可以被成功地执行。



现在我们把它和 `String` 类型的变量对比一下。在 `Java` 中，这样的变量可以持有两种值，分别是 `String` 的实例和 `null` 。这两种值完全不一样：就连 `Java` 自己的 `instanceof` 运算符都会告诉你 `null` 不是 `String` 。这两种值的操作也完全不一样：真实的 `String` 实例允许你调用它的任何方法，而 `null` 值只允许非常有限的操作 。



这说明 `Java `的类型系‘统在这种情况下不能很好地工作 。即使变量拥有声明的类型 `String` 你依然无法知道能对该变量的值做些什么，除非做额外的检查。你往往会跳过这些检查 ，因为你觉得你了解程序中大概的数据流动，并确定在某个点上这个值不可能为 `null` 。有时候你想错了，而你的程序就会因为`NullPointerException` 而崩溃。



`Kotlin`的可空类型为这类问题提供了全面的解决方案。区分开可空类型和非空类型使事情变得明朗：哪些对值的操作是允许的，哪些操作有会导致运行时异常并因此被禁止。



可空的和非空的对象在运行时没有什么区别；可空类型并不是非空类型的包装 。 所有的检查都发生在编译期 。这意味着使用 `Kotlin` 的可空类型并不会在运行时带来额外的开销 。



现在来看看在`Kotlin` 中如何使用可空类型，以及为什么和它们打交道并不令人厌烦 。我们从能够安全访问可空值的特殊运算符说起。



## 安全调用运算符 "?."

`Kotlin`的弹药库中最有效的一种工具就是安全调用运算符：`?.`，它允许把一次 `null` 检查和一次方法调用合并成一个操作。例如，表达式 `s?.uppercase()`等同于下面这种烦琐的写法：`if (s!=null) s.uppercase() else null` 。



注意 ，这次调用的结果类型也是可空的。尽管 `String.uppercase()` 会返回 `String` 类型的值，但 `s` 是可空的时候，表达式 `s?.uppercase()`的结果类型是 `String?` :

```kotlin
fun printAllCaps(s:String?){
    val allCaps : String? = s?.uppercase()
    // allCaps可能是null
    println(allCaps)
}

fun main() {
    printAllCaps("abc")
    // ABC
    printAllCaps(null)
    // null
}
```

安全调用不光可以调用方法，也能用来访问属性。下面这个例子展示了一个具有可空属性的简单 `Kotlin` 类，以及访问这个属性时安全调用运算符的用法。

```kotlin
class Employee(val name:String,val manager: Employee?)

fun managerName(employee: Employee):String? = employee.manager?.name

fun main() {
    val ceo = Employee("Da Boss",null)
    val  developer = Employee("Bob Smith",ceo)
    println(managerName(developer))
    // Da Boss
    println(managerName(ceo))
    // null
}
```

如果对象图中有多个可空类型的属性，通常可以在同 一个表达式中方便地使用多个安全调用。假如要使用不同的类来保存关于个人的信息、他们的公司，以及公司的地址，而公司和地址都可以省略。使用`?.`运算符，不需要任何额外的检查，就可以在一行代码中访问到 `Person` 的 `country` 属性 。

```kotlin
class Address(val streetAddress: String,val zipCode:Int,
            val city:String,val country:String)

class Company(val name:String,val address: Address?)


class Person(val name:String,val company:Company?)

fun Person.countryName():String{
    // 多个安全调用链接在一起
    val country = this.company?.address?.country
    return if (country != null) country else "Unknown"
}

fun main() {
    val person = Person("Dmitry",null)
    println(person.countryName())
    // Unknown
}
```



带 `null` 检查的方法调用序列在 `Java` 代码中太常见了，现在`Kotlin`可以让它们变得更简洁。但还有不必要的重复代码： 用一个值和`null` 比较，如果这个值不为空就返回这个值 ，否则返回其他的值。接下来看看 `Kotlin` 是否能帮助去掉这些重复代码。



## Elvis运算符："?:"

`Kotiin` 有方便的运算符来提供代替 `null` 的默认值。它被称作 `Elvis`运算符（或者 `null `合并运算符）。它看起来就像这样：`?:`。下面展示了它是如何使用的：

```kotlin
fun foo(s:String?){
    // 如果s为null，结果是一个空的字符串
	val t:String = s?:""
}
```

`Elvis` 运算符接收两个运算数，如果第一个运算数不为 `null` ，运算结果就是第一个运算数；如果第一个运算数为 `null`，运算结果就是第二个运算数。



`Elvis` 运算符经常和安全调用运算符一起使用，用 一个值代替对 `null` 对象调用方法时返回的 `null` 。下面展示了 如何使用这种模式来简化代码:

```kotlin
fun strLenSafeUsingElvis(s:String?): Int =  s?.length ?:0

fun main(){
    println(strLenSafeUsingElvis("abc"))
    // 3
    println(strLenSafeUsingElvis(null))
    // 0
}
```



函数 `countryName` 现在也可以使用一行代码完成:

```kotlin
fun Person.countryName() =
	company?.address?.country ?:”Unknown"
```

在 `Kotiin` 中有一种场景下 `Elvis` 运算符会特别顺手，像 `return` 和 `throw` 这样的操作其实是表达式，因此可以把它们写在 `Elvis` 运算符的右边。这种情况下，如果 `Elvis` 运算符左边的值为 `null` ，函数就会立即返回一个值或者抛出 一个异常 。 如果函数中需要检查先决条件，这个方式特别有用。



来看看如何使用这个运算符来实现一个打印包含个人公司地址的出货标签的函数。下面这个代码清单重复了所有类的声明——`Kotlin` 中它们是如此简洁，这不是一个问题。

```kotlin
class Address(val streetAddress: String,val zipCode:Int,
            val city:String,val country:String)

class Company(val name:String,val address: Address?)


class Person(val name:String,val company:Company?)

fun printShippingLabel(person: Person){
    val address = person.company?.address
        ?: throw IllegalArgumentException("No Address") // 如果缺少 address就抛出异常
    // 此时address肯定不为空
    with(address){
        println(streetAddress)
        println("$zipCode $city, $country")
    }
}

fun main() {
    val address = Address("Elsestr. 47",80687,"Munich","Germany")
    val jetbrains = Company("Jetbrains",address)
    val person = Person("Dmitry",jetbrains)

    printShippingLabel(person)
    // Elsestr. 47
    // 80687 Munich, Germany

    printShippingLabel(Person("Alexey",null))
    // java.lang.IllegalArgumentException("No Address")
}
```

如果一切正常，函数 `printShippingLabel` 会打印出标签 。 如果地址不存在，它不会只是抛出一个带行号的 `NullPointerException` ，相反，它会报告一个有意义的错误。如果地址存在，标签会包含街道地址、邮编、城市和国家 。 留意前一章中见过的 `with` 函数是如何被用来避免在这一行中重复四次 `address` 的 。



## 安全转换："as?"

用来转换类型的常规 `Kotlin` 运算符： `as` 运算符。和常规的 `Java` 类型转换 一样，如果被转换的值不是试图转换的类型，就会抛出`ClassCastException` 异常。当然可以结合 `is` 检查来确保这个值拥有合适的类型。但是作为一种安全简洁的语言，`Kotlin` 没有更优雅的解决方案吗？当然有。



`as?`运算符尝试把值转换成指定的类型， 如果值不是合适的类型就返回 `null`。



一种常见的模式是把安全转换和`Elvis`运算符结合使用。例如，实现`equals`方法的时候这样的用法非常方便。

```kotlin
class PersonObj(val firstName:String,val lastName:String){
    override fun equals(other: Any?): Boolean {
        // 尝试使用as?将other转换为PersonObj对象，如果能转换则将转换后的结果赋值给otherPerson
        // 如果不能转换则as?的结果为null，直接执行return false返回
        val otherPerson = other as? PersonObj ?: return false

        // 在安全转换之后，变量otherPerson被智能地转换为Person类型
        return otherPerson.firstName == firstName &&
                otherPerson.lastName == lastName
    }

    override fun hashCode(): Int  =
        firstName.hashCode() * 37 + lastName.hashCode()

}

fun main() {
    val p1 = PersonObj("Dmitry","Jemerov")
    val p2 = PersonObj("Dmitry","Jemerov")
    println(p1 == p2)
    // true
    println(p1.equals(42))   // 运算符会调用equals方法
    // false
}
```

使用这种模式，可以非常容易地检查实参是否是适当的类型，转换它，并在它的类型不正确时返回`false`，而且这些操作全部在同一个表达式中。当然，这种场景下只能转换也会生效：当检查过类型并拒绝了`null`值，编译器就确定了变量`otherPerson` 值的类型是 `Person` 并让你能够相应地使用它。



安全调用、安全转换和 `Elvis` 运算符都非常有用，它们出现在 `Kotlin` 代码中的频率非常高。但有时并不需要 `Kotlin` 的这些支持来处理 `null` 值，只需要直接告诉编译器这个值实际上并不是 `null` 。接下来我们看看你如何做到这一点 。



## 非空断言："!!"

非空断言是 `Kotlin` 提供的最简单直率的处理可空类型值的工具。它使用双感叹号表示，可以把任何值转换成非空类型。如果对 `null` 值做非空断言，则会抛出异常。



下面这个小例子是一个函数，它使用这种断言来把可空的实参转换成非空。

```kotlin
fun ignoreNulls(s: String?){
    // 异常指向这一行
    val sNotNull:String = s!!
    println(sNotNull.length)
}

fun main(){
    ignoreNulls(null)
    // java.lang.NullPointerException
}
```

如果上面函数中 `s` 为 `null` 会发生什么？`Kotlin` 没有其他选择，它会在运行时抛出一个异常（ 一种特殊的 `NullPointerException` ）。但是注意异常抛出的位置是非空断言所在的那一行，而不是接下来试图使用那个值的一行。本质上，是在告诉编译器 ：“我知道这个值不为 `null` ，如果我错了我准备好了接收这个异常。”



## let函数

`let` 函数让处理可空表达式变得更容易 。 和安全调用运算符一起，它允许对表达式求值，检查求值结果是否为 `null` ，并把结果保存为一个变量。 所有这些动作都在同一个简洁的表达式中。



可空参数最常见的一种用法应该就是被传递给一个接收非空参数的函数 。比如说下面这个 `sendEmailTo` 函数，它接收一个 `String` 类型 的参数井 向这个地址发送一封邮件。这个函数在 `Kotlin` 中是这样写的，它需要一个非空的参数：

```kotlin
fun sendEmailTo(email: String){ /* ... */}
```



不能把可空类型的值传给这个函数：

```kotlin
>>> val email:String? = ...
>>> sendEmailTo(email)
ERROR: Type mismatch
```

必须显式地检查这个值不为 `null`:

```kotlin
if (email != null) sendEmailTo(email)
```

但还有另外一种处理方式：使用 `let` 函数，并通过安全调用来调用它。`let`函数做的所有事情就是把一个调用它的对象变成 `lambda` 表达式的参数 。 如果结合安全调用语法，它能有效地把调用 `let` 函数的可空对象，转变成非空类型。



`let` 函数只在 `email` 的值非空时才被调用，所以就能在 `lambda` 中把 `email`当作非空的实参使用。

```kotlin
email?.let { email -> sendEmailTo(email)}
```



使用自动生成的名字 `it` 这种简明语法之后，上面的代码就更短了:`email?.let{sendEmailTo(it)}` 。 下面这个更完整的例子展示了这种模式。

```kotlin
fun sendEmailTo(email:String){
    println("Sending email to $email")
}

fun main() {
    var email:String? = "yole@example.com"
    email?.let { sendEmailTo(it) }
    // Sending email to yole@example.com
    email = null
    email?.let { sendEmailTo(it) }
}
```

注意，如果有一些很长的表达式结果不为`null`，而又要使用这些结果时，`let` 表示法特别方便 。 这种情况下不必创建一个单独的变量。对比一下显式的`if`检查：

```kotlin
val person: Person? = getTheBestPersonInTheWorld()
if(person != null) sendEmailTo(person.email)
```

和功能相同但没有额外变量的代码：

```kotlin
getTheBestPersonInTheWorld()?.let{sendEmailTo{it.email}}
```

这个函数返回 `null` ，所以`lambda` 中的代码永远不会执行：

```kotlin
fun getTheBestPersonInTheWorld(): Person? = null
```

当需要检查多个值是否为 `null` 时，可以用嵌套的 `let` 调用来处理。但在大多数情况下，这种代码相当啰嗦又难以理解。用普通的 `if` 表达式来一次性检查所有值通常更简单 。



另一种常见的情况是，属性最终是非空的，但不能使用非空值在构造方法中初始化 。 接下来看看 `Kotlin` 如何能够处理这种情况。





## 延迟初始化的属性

很多框架会在对象实例创建之后用专门的方法来初始化对象。例如，在`Android` 中，`Activity` 的初始化就发生在 `onCreate` 方法中。而 且`JUnit` 则要求把初始化的逻辑放在用`＠Before` 注解的方法中 。



但是不能在构造方法中完全放弃非空属性的初始化器 ， 仅仅在一个特殊的方法里初始化它 。 `Kotlin` 通常要求在构造方法中初始化所有属性，如果某个属性是非空类型，就必须提供非空的初始化值。否则 ， 就必须使用可空类型。如果这样做，该属性的每一次访问都需要 `null` 检查或者`!!`运算符。



```kotlin
class MyService {

    fun performAction():String = "foo"

}

class MyTest{
    private var myService : MyService? = null

    @Before fun setUp(){
        myService = MyService()
    }

    @Test fun testAction(){
        Assert.assertEquals("foo",
            // 必须注意可空性：要么用!!，要么用?.
            myService!!.performAction())
    }
}
```

这段代码很难看，尤其是要反复使用这个属性的时候。为了解决这个问题，可以把 `myService` 属性声明成可以延迟初始化的 ，使用 `lateinit` 修饰符来完成这样的声明 。



```kotlin
class MyService {

    fun performAction():String = "foo"

}

class MyTest{
    // 声明一个不需要初始化器的非空类型的属性
    private lateinit var myService : MyService

    @Before fun setUp(){
        // 像之前的例子一样在setUp方法中初始化属性
        myService = MyService()
    }

    @Test fun testAction(){
        Assert.assertEquals("foo",
            // 不需要null检查直接访问属性
            myService.performAction())
    }
}
```



注意 ，延迟初始化的属性都是 `var` ，因为需要在构造方法外修改它的值 ，而`val`属性会被编译成必须在构造方法中初始化的 `final` 字段 。尽管这个属性是非空类型，但是你不需要在构造方法中初始化它。 如果在属性被初始化之前就访问了它，会得到这个异常“lateinit property myService has not been initialized”(lateinit 的属性 myService 没有被初始化 ） 。 该异常清楚地说明了发生了什么，比一般的 `NullPointerException` 要容易理解得多。



注意：`lateinit` 属性常见的一种用法是依赖注入 。在这种情况下，`lateinit` 属性的值是被依赖注入框架从外部设置的 。 为了保证和各种`Java`（依赖注入）框架的兼容性，`Kotlin` 会自动生成一个和 `lateinit` 属性具有相同可见性的字段。 如果属性的可见性是 `public` ，生成字段的可见性也是 `public`。



## 可空类型的扩展

为可空类型定义扩展函数是一种更强大的处理 `null` 值的方式。可以允许在 `null` 的对象上调用相应的对象方法，并在该函数中处理 `null` ，而不是在确保变量不为 `null` 之后再调用它的方法。只有扩展函数才能做到这一点，普通成员方法的调用是通过对象实例来分发的，因此实例为 `null` 时（成员方法）永远不能被执行。



`Kotlin`标准库中定义的`String`的两个扩展函数 `isErnpty` 和 `isBlank` 就是这样 的例子 。第一个函数判断字符串是否是一个空的字符串 ”” 。第二个函数则判断它是否是空的或者它只包含空白字符。通常用这些函数来检查字符串是有价值的，以确保对它的操作是有意义的。像处理无意义的空字符串和空白字符串这样处理 `null` 也很有用。事实上，的确可以这样做：函数`isEmptyOrNull` 和 `isNullOrBlank` 就可以由 `String?`类型的接收者调用。

```kotlin
fun verifyUserInput(input :String?){
    // 这里不需要安全调用
    if (input.isNullOrBlank()){
        println("Please fill in the required fields")
    }
}

fun main() {
    verifyUserInput(" ")
    // Please fill in the required fields
    verifyUserInput(null)  // 这里传递null进函数里，函数里执行null对象的isNullOrBlank并不会导致任何异常
    // Please fill in the required fields
}
```

不需要安全访问，可以直接调用为可空接收者声明的扩展函数。这个函数会处理可能的 `null` 值。



函数 `isNullOrBlank` 显式地检查了 `null` ，这种情况下返回 `true` ，然后调用 `isBlank` ，它只能在非空 `String` 上调用：

```kotlin
fun CharSequence?.isNullOrBlank(): Boolean { // 可空字符串的扩展
    return this == null || this.isBlank() // 第二个this使用了智能转换
}
```



**当为一个可空类型（以`?`结尾）定义扩展函数时，这意味着可以对可空的值调用这个函数；并且函数体中的 `this` 可能为 `null` ，所以必须显式地检查 。在 `Java `中，`this` 永远是非空的，因为它引用的是当前所在这个类的实例。而在`Kotlin` 中，这并不永远成立：在可空类型的扩展函数中，`this` 可以为 `null` 。**





注意：之前讨论的 `let` 函数也能被可空的接收者调用，但它并不检查值是否为 `null` 。如果你在一个可空类型直接上调用 `let` 函数，而没有使用安全调用运算符，`lambda` 的实参将会是可空的：

```kotlin
>>> val person: Person? = ...
>>> person.let {sendEmailTo(it)} // 没有安全调用，所以it是可空类型
ERROR: Type mismatch
```

因此，如果想要使用 `let` 来检查非空的实参，就必须使用安全调用运算符`?.`，就像之前看到的代码一样： `person?.let{sendEmailTo(it)}` 。



定义自己的扩展函数时，需要考虑该扩展是否需要为可空类型定义 。 默认情况下，应该把它定义成非空类型的扩展函数 。 如果发现大部分情况下需要在可空类型上使用这个函数，可以稍后再安全地修改它（不会破坏其他代码） 。



## 类型参数的可空性

`Kotlin` 中所有泛型类和泛型函数的类型参数默认都是可空的。任何类型，包括可空类型在内，都可以替换类型参数。这种情况下，使用类型参数作为类型的声明都允许为`null`，尽管类型参数 `T` 并没有用问号结尾。参考下面这个例子。

```kotlin
fun <T> printHashCode(t: T){
	// 因为t可能为null，所以必须使用安全调用
	println(t?.hashCode())
}
>>> printHashCode(null)  //T被推导成Any?可空类型
null 
```

在 `printHashCode` 调用中，类型参数 `T` 推导出的类型是可空类型 `Any?`。因此，尽管没有用问号结尾 ，实参 `t` 依然允许持有 `null`。



**要使类型参数非空，必须要为它指定一个非空的上界，那样泛型会拒绝可空值作为实参。**



```kotlin
fun <T:Any> printHashCode(t: T){
	println(t.hashCode())
}
>>> printHashCode(null)  //这段代码是无法编译的：不能传递null，因为期望的是非空值
ERROR: Type parameter bound 'T' is not satisfied
>>> printHashCode(42)
42
```

注意必须使用问号结尾来标记类型为可空的 ，没有问号就是非空的。类型参数是这个规则唯一 的例外 。



# 基本数据类型和其他数据类型

这一节将描述程序中使用的基本类型，例如 `Int` 、`Boolean` 和 `Any`。**与 `Java`不一样的是，`Katlin` 并不区分基本数据类型和它们的包装类。**稍后就会了解到背后的原因和底层的运作机制，还将看到 `Kotlin` 类型和像 `Object` 和 `Void` 这样的`Java` 类型之间的对应关系。



## 基本数据类型：Int、Boolean及其他

`Java` 把基本数据类型和引用类型做了区分 。一个基本数据类型（如`int` ）的变量直接存储了它的值，而一个引用类型（如 `String` ）的变量存储的是指向包含该对象的内存地址的引用。



**基本数据类型的值能够更高效地存储和传递，但是不能对这些值调用方法，或是把它们存放在集合中。`Java` 提供了特殊的包装类型（比如 `java.lang.Integer` ），在需要对象的时候对基本数据类型进行封装 。因此，不能用`Collection<int>`来定义一个整数的集合，而必须用 `Collection < Integer>`来定义 。**



`Kotlin`并不区分基本数据类型和包装类型，使用的永远是同一个类型（ 比如：`Int`):

```kotlin
val i: Int = 1
val list:List<Int> = listOf(1,2,3)
```

这样很方便。此外，还能对一个数字类型的值调用方法 。 例如下面这段代码中 ，使用了标准库的函数 `coerceIn` 来把值限制在特定范围内：

```kotlin
fun showProgress(progress:Int){
    val percent = progress.coerceIn(0,100)
    println("We`re ${percent}% done!")
}

fun main(){
    showProgress(146)
    // We`re 100% done!
}
```

如果基本数据类型和引用类型是一样的，是不是意味着 `Kotlin` 使用对象来表示所有的数字？这样不是非常低效吗？确实低效，所以 `Kotlin` 并没有这样做 。



在运行时，数字类型会尽可能地使用最高效的方式来表示 。 大多数情况下一一对于变量 、属性、参数和返回类型——`Kotlin` 的 `Int` 类型会被编译成 `Java` 基本数据类型 `int` 。 唯一不可行的例外是泛型类，比如集合 。 用作泛型类型参数的基本数据类型会被编译成对应的 `Java` 包装类型 。 例如， `Int` 类型被用作集合类的类型参数时 ，集合类将会保存对应包装类型 `java.lang.Integer` 的实例 。



对应到 `Java` 基本数据类型的类型完整列表如下：

- 整数类型——Byte 、Short 、Int, Long
- 手点数类型 ——Float、Double
- 字符类型——Char
- 布尔类型——Boolean



像 `Int` 这样的 `Kotlin` 类型在底层可以轻易地编译成对应的 `Java` 基本数据类型，因为两种类型都不能存储 `null` 引用。反过来也差不多： 当在 `Kotlin` 中使用 `Java`声 明时，`Java` 基本数据类型会变成非空类型（而不是平台类型），因为它们不能持有 `null` 值。



## 可空的基本数据类型：Int？、Boolean？及其他
`Kotlin` 中的可空类型不能用 `Java` 的基本数据类型表示，因为 `null` 只能被存储在 `Java` 的引用类型的变量中。这意味着任何时候只要使用了基本数据类型的可空版本，它就会编译成对应的包装类型。



