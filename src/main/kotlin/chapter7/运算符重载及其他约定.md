`Java`在标准库中有一些与特定的类相关联的语言特性 。 例如，实现了`java.lang.Iterable` 接口的对象可以在 `for` 循环中使用，实现了 `java.lang.Aut oCloseable` 接口的对象可以在 `try-with-resources` 语句中使用 。



**`Kotlin` 也有许多特性的原理非常类似，通过调用自己代码中定义的函数，来实现特定语言结构 。 但是，在`Kotlin` 中，这些功能与特定的函数命名相关，而不是与特定的类型绑定 。 例如，如果在类中定义了一个名为 `plus` 的特殊方法，那么按照约定，就可以在该类的实例上使用＋运算符。因此，在 `Kotlin` 中，把这种技术称为约定 。** 



`Kotlin` 使用约定的原则，并不像 `Java` 那样依赖类型，因为它允许开发人员适应现有的 `Java` 类，来满足 `Kotlin` 语言特性的要求。由类实现的接口集是固定的，而`Kotlin` 不能为了实现其他接口而修改现有的类。另一方面，`Kotlin` 可以通过扩展函数的机制来为现有的类增添新的方法 。 可以把任意约定方法定义为扩展函数，从而适应任何现有的 `Java` 类而不用修改其代码。



作为这一章 的例子，将实现一个简单的 `Point` 类，用来表示屏幕上的 一个点。这样的类存在于大多数的 `UI` 框架中，也可以简单地把这里的定义用到自己的开发环境中去：

```kotlin
data class Point(val x:Int,val y:Int)
```



# 重载算术运算符

在 `Kotlin` 中使用约定的最直接的例子就是算术运算符 。在 `Java` 中，全套的算术运算只能用于基本数据类型，`+`运算符可以与 `String` 值一起使用。但是，这些运算在其他一些情况下用起来也很方便。例如，在使用 `BigInteger` 类处理数字的时候，使用`+`号就比调用 `add` 方法显得更为优雅：给集合添加元素的时候，可能也在想要是能用`+=`运算符就好了。在 `Kotlin` 中就可以这样做，在这一节就来看一下到底它是如何工作的。



## 重载二元算术运算

要支持的第一个运算，就是把两个点加到一起。这个运算需要把点的（X,Y)坐标分别加到一起。可以这样来实现：

```kotlin
data class PointPlus(val x:Int,val y:Int){

    // 定义一个名为plus的方法
    operator fun plus(other:PointPlus):PointPlus{
        // 坐标分别相加，然后返回一个新的点
        return PointPlus(x + other.x,y + other.y)
    }
}

fun main() {
    val p1 = PointPlus(10,20)
    val p2 = PointPlus(30,40)
    // 通过使用+号来调用plus方法
    println(p1 + p2)
    // PointPlus(x=40,y=60)
}
```

注意，**使用 `operator` 关键字来声明 `plus` 函数。用于重载运算符的所有函数都需要用该关键字标记，用来表示打算把这个函数作为相应的约定的实现，并且不是碰巧地定义一个同名函数。**



除了把这个运算符声明为一个成员函数外，也可以把它定义为一个扩展函数。

```kotlin
operator fun Point.plus(other: PointPlus): PointPlus{
	return PointPlus(x+other.x,y+other.y)
}
```

这样实现是一样的。后续的示例中将会使用扩展函数的语法来写，这是给第三方库的类定义约定扩展函数的常用模式。而且 ，对于自己的类这种语法也同样适用。



和其他一些语言相比 ， 在 `Kotlin` 中不管是定义还是使用重载运算符都更为简单 ，因为不能定义自己的运算符。`Kotlin` 限定了能重载哪些运算符 ，以及需要在自己的类中定义的对应名字的函数。下面的表列举了能定义的二元运算符 ，以及对应的函数名称 。

| 表达式 | 函数名 |
| ------ | ------ |
| a * b  | times  |
| a / b  | div    |
| a % b  | mod    |
| a + b  | plus   |
| a - b  | minus  |



**自定义类型的运算符，基本上和与标准数字类型的运算符有着相同的优先级。例如，如果是 `a+b *c` ，乘法将始终在添加之前执行，即使已经自己定义了这些运算符。运算符飞／和%具有相同的优先级，高于＋和 － 运算符的优先级。**



**当在定义一个运算符的时候 ，不要求两个运算数是相同的类型。**例如，来定义一个运算符，它允许用一个数字来缩放一个点，可以用它在不同坐标系之间做转换。

```kotlin
data class PointTimes(val x:Int,val y:Int){


}

operator fun PointTimes.times(scale: Double): PointTimes{
    return PointTimes((x * scale).toInt(),(y * scale).toInt())
}

fun main() {
    val p = PointTimes(10,20)
    println(p * 1.5)
    // PointTimes(x,15,y=30)
}
```

注意 ，`Kotlin` 运算符不会自动支持交换性 （交换运算符的左右两边）。如果希望用户能够使用 `1.5 * p` 以外，还能使用 `p * 1.5` ，需要为它定义一个单独的运算符： `operator fun Double.times(p : PointTimes): PointTimes` 。



运算符函数的返回类型也可以不同于任一运算数类型。例如，可以定义一个运算符，通过多次重复单个字符来创建字符串。

```kotlin
// 多次重复单个字符来创建字符串
operator fun Char.times(count: Int):String{
    return toString().repeat(count)
}

fun main() {
    println('a' * 3)
    // aaa
}
```

这个运算符，接收一个`Char`作为左值，`Int`作为右值，然后返回一个`String`类型。这样的运算数和结果类型的组合是允许的。



**注意，和普通的函数一样，可以重载`operator`函数：可以定义多个同名的，但参数类型不同的方法。**



## 重载复合赋值运算符



通常情况下，当在定义像`plus`这样的运算符函数时，`Kotlin`不止支持`+`号运算，也支持`+=`。像`+=`、`-=`等这些运算符被称为复合赋值运算符。看这个例子：

```kotlin
var point = PointPlus(1,2)
point += PointPlus(3,4)
println(point)
// PointPlus(x=4,y=6)
```

 这等同于`point = point + PointPlus(3,4)`的写法。当然 ，这个只对于可变变量有效。



在一些情况下，定义`+=`运算可以修改使用它的变量所引用的对象，但不会重新分配引用 。将一个元素添加到可变集合，就是一个很好的例子：

```kotlin
>>> val numbers = ArrayList<Int>()
>>> numbers += 42
>>> println(numbers[0])
42
```

如果定义了一个返回值为 `Unit` ，名为 `plusAssign` 的函数，`Kotlin` 将会在用到`+=`运算符的地方调用它。其他二元算术运算符也有命名相似的对应函数：如`minusAssign` 、`timesAssign` 等 。



`Kotlin` 标准库为可变集合定义 了 `plusAssign` 函数，在前面的例子中可以这样使用：

```kotlin
operator fun <T> MutableCollection<T>.plusAssign(element: T){
	this.add(element)
}
```

当在代码中用到`+=`的时候，理论上 `plus` 和 `plusAssign`都可能被调用。如果在这种情况下，两个函数都有定义且适用，编译器会报错 。一种可行的解决办法是，替换运算符的使用为普通函数调用。另一个办法是，用 `val` 替换 `var` ，这样 `plusAssign` 运算就不再适用。但一般来说，最好一致地设计出新的类：**尽量不要同时给一个类添加 `plus` 和 `plusAssign` 运算。如果像前面的一个示例中的 `Point` ，这个类是不可变的，那么就应该只提供返回 一个新值（如 `plus` ）的运算 。如果一个类是可变的，比如构建器，那么只需要提供 `plusAssign` 和类似的运算就够了。**



**`Kotlin` 标准库支持集合的这两种方法。`+`和 `-`运算符总是返回一个新的集合。`+=`和`-=`运算符用于可变集合时，始终在一个地方修改它们；而它们用于只读集合时 ，会返回一个修改过的副本。作为它们的运算数，可以使用单个元素，也可以使用元素类型一致的其他集合：**

```kotlin
>>> val list = arrayListOf(1,2)
>>> list += 3
>>> val newList = list + listOf(4,5)
>>> println(list)
[1,2,3]
>>> println(newList)
[1,2,3,4,5]
```



## 重载一元运算符

重载一元运算符的过程与在前面看到的方式相同：用预先定义的一个名称来声明函数（成员函数或扩展函数），并用修饰符 `operator`标记。

```kotlin
data class PointUnaryMinus(val x:Int,val y:Int){

}

// 一元运算符，无参数
operator fun PointUnaryMinus.unaryMinus(): PointUnaryMinus{
    // 坐标取反，然后返回
    return PointUnaryMinus(-x,-y)
}

fun main() {
    val p = PointUnaryMinus(10,20)
    println(-p)
    // PointUnaryMinus(x=-10, y=-20)
}
```

用于重载一元运算符的函数，没有任何参数。



可重载的一元算法的运算符：

| 表达式  | 函数名     |
| ------- | ---------- |
| +a      | unaryPlus  |
| -a      | unaryMinus |
| !a      | not        |
| ++a,a++ | inc        |
| --a,a-- | dec        |

当定义 `inc` 和 `dec` 函数来重载自增和自减的运算符时 ，编译器自动支持与普通数字类型的前缀和后缀自增运算符相同的语义 。考虑一下用来重载 `BigDecimal`类的`++`运算符的这个例子。

```kotlin
import java.math.BigDecimal

operator fun BigDecimal.inc() = this + BigDecimal.ONE

fun main() {
    var bd = BigDecimal.ZERO
    println(bd++)  //在println语句执行后增加
    // 0
    println(++bd)  // 在println语句执行前增加
    // 2
}
```

后缀运算`++`首先返回 `bd`变量的当前值，然后执行 `++` ，这个和前缀运算相反。打印的值与使用 `Int` 类型的变量所看到的相同 ， 不需要额外做什么特别的事情就能支持。



# 重载比较运算符

与算术运算符一样，在 `Kotlin` 中，可以对任何对象使用比较运算符（`==`、`!=`、 `>` 、`<`等），而不仅仅限于基本数据类型。不用像 `Java` 那样调用 `equals` 或 `compareTo`函数，可以直接使用比较运算符。



## 等号运算符："equals"

如果在 `Kotlin` 中使用`==`运算符，它将被转换成 `equals` 方法的调用。这只是要讨论的约定原则中的一个。



**使用`!=`运算符也会被转换成 `equals` 函数的调用，明显的差异在于，它们的结果是相反的。注意，和所有其他运算符不同的是，`==`和`!=`可以用于可空运算数，因为这些运算符事实上会检查运算数是否为 `null` 。比较 `a== b` 会检查 `a` 是否为非空，如果不是，就调用 `a.equals(b)`；否则，只有两个参数都是空引用，结果才是 `true` 。**



对于 `Point` 类，因为己经被标记为数据类，`equals` 的实现将会由编译器自动生成。但如果要手动实现，那么代码可以是这样的。

```kotlin
data class PointEquals(val x:Int,val y:Int){

    // 重写在Any中定义的方法
    override fun equals(other: Any?): Boolean {
        // 检查参数是否与this是同一个对象
        if (other === this) return true
        // 检查参数类型
        if (other !is PointEquals) return false
        // 智能转换为PointEquals来访问x、y属性
        return other.x == x && other.y == y
    }
}

fun main() {
    println(PointEquals(10,20) == PointEquals(10,20))
    // true
    println(PointEquals(10,20) != PointEquals(5,5))
    // true
    println(null == PointEquals(1,2))
    // false
}
```

这里使用了恒等运算符（`===`）来检查参数与调用 `equals` 的对象是否相同 。**恒等运算符(`===`)与 `Java` 中的`==`运算符是完全相同的：检查两个参数是否是同 一个对象的引用（如果是基本数据类型，检查它们是否是相同的值）。在实现了 `equals` （方法）之后 ，通常会使用这个运算符来优化调用代码。注意，`===`运算符不能被重载。**



**`equals` 函数之所以被标记为 `override` ，那是因为与其他约定不同的是，这个方法的实现是在 `Any` 类中定义 的（ `Kotlin` 中的所有对象都支持等式比较）。这也解释了为什么不需要将它标记为 `operator: Any` 中的基本方法就己经标记了，而且函数的 `operator` 修饰符也适用于所有实现或重写它的方法 。还要注意，`equals` 不能实现为扩展函数，因为继承自 `Any` 类的实现始终优先于扩展函数。**



这个例子显示使用`!=`运算符也会转换为 `equals` 方法的调用。编译器会自动对返回值取反 ，因此不需要再做别的事情 ，就可以正常运行。



## 排序运算符：compareTo

在 `Java` 中，类可以实现 `Comparable` 接口，以便在比较值的算法中使用，例如在查找最大值或排序的时候。接口中定义的 `compareTo` 方法用于确定 一个对象是否大于另一个对象 。 但是在 `Java` 中，这个方法的调用没有简明语法。只有基本数据类型能使用 `<` 和 `>` 来比较，所有其他类型都需要明确写为 `element1.compareTo(element2)`。



`Kotlin` 支持相同的 `Comparable` 接口 。 但是接口中定义的 `compareTo` 方法可以按约定调用，比较运算符（`<`，'>'，`<=`和`>=`） 的使用将被转换为 `compareTo`。`compareTo` 的返回类型必须为 `Int`。 `p1 < p2` 表达式等价于`p1.compareTo(p2) < 0` 。其他比较运算符的运算方式也是完全一样的。



因为没有明显的正确方式来比较两个点，所以用旧的 `Person` 类作为例子，来看看如何实现这个方法。这个实现将对地址簿排序（先比较名字中的姓氏，如果姓氏相同，再比较名字）。

```kotlin
class PersonCompare (
    val firstName:String,val lastName:String
) : Comparable<PersonCompare>{

    override fun compareTo(other: PersonCompare): Int {
        // 按顺序调用给定的方法，并比较它们的值
        return compareValuesBy(this,other,
            PersonCompare::lastName,PersonCompare::firstName)
    }
}

fun main() {
    val p1 = PersonCompare("Alice","Smith")
    val p2 = PersonCompare("Bob","Johnson")
    println(p1 < p2)
    // false
}
```

在这种情况下，可以实现 `Comparable` 接口，这样 `Person` 对象不仅可以在`Kotlin` 代码中用来比较，还可以被 `Java` 函数（比如用于对集合进行排序的功能）进行比较。与 `equals` 一样，`operator` 修饰符己经被用在了基类的接口中，因此在重写该接口时无须再重复。



要注意如何使用 `Kotlin` 标准库中的 `compareValuesBy` 函数来简洁地实现`compareTo` 方法。这个函数接收用来计算比较值的一系列回调，按顺序依次调用回调方法，两两一组分别做比较，井返回结果。如果值不同，则返回比较结果；如果它们相同，则继续调用下一个；如果没有更多回调来调用，则返回 0。这些回调函数可以像 `lambda` 一样传递，或者像这里做的一样，作为属性引用传递 。



注意，尽管自己直接实现字段的比较会运行得更快一点 ，然而这样会包含更多的代码。一般情况下，更推荐使用简洁的写法，不用过早地担心性能问题，除非提前知道这个实现将会被频繁调用。



所有 `Java` 中实现了 `Comparable` 接口的类，都可以在 `Kotlin` 中使用简洁的运算符语法，不用再增加扩展函数：

```kotlin
>>> println("abc" < "bac")
true
```



# 集合与区间的约定

处理集合最常见的一些操作是通过下标来获取和设置元素，以及检查元素是否属于当前集合。所有的这些操作都支持运算符语法：要通过下标获取或设置元素 ，可以使用语法 `a[b]` （称为下标运算符） 。 可以使用 `in` 运算符来检查元素是否在集合或区间内，也可以迭代集合。可以作为集合的自定义类。来看看用于支持这些操作的约定。



## 通过下标来访问元素：get和set

己经知道，在 `Kotlin` 中，可以用类似 `Java` 中数组的方式来访问 `map` 中的元素一一使用方括号：

```kotlin
val value = map[key]
```

也可以用同样的运算符来改变一个可变 `map` 的元素：

```kotlin
mutableMap[key] = newValue
```

来看看它是如何工作的。**在 `Kotlin` 中，下标运算符是一个约定。使用下标运算符读取元素会被转换为 `get` 运算符方法的调用 ，井且写入元素将调用 `set` 。`Map` 和`MutableMap` 的接口己经定义了这些方法。**看看如何给自定义的类添加类似的方法。



可以使用方括号来引用点的坐标： `p[0]`访问 `X` 坐标，`p[1]`访问 `Y` 坐标。下面是它的实现和调用：

```kotlin
data class PointGetSet(val x: Int,val y:Int)


// 定义一个名为get的运算符函数
operator fun PointGetSet.get(index:Int):Int{
    return when(index){
        // 根据给出的index返回对应的坐标
        0 -> x
        1 -> y
        else -> throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}


fun main() {
    val p = PointGetSet(10,20)
    println(p[1])
    // 20
}
```

只需要定义一个名为 `get` 的函数，并标记 `operator` 。之后，像`p[1]`这样的表达式，其中 `p` 具有类型 `Point` ，将被转换为 `get` 方法的调用。



注意，`get` 的参数可以是任何类型，而不只是 `Int` 。例如，当对 `map` 使用下标运算符时，参数类型是键的类型，它可以是任意类型。还可以定义具有多个参数的 `get` 方法。例如，如果要实现一个类来表示二维数组或矩阵，可以定义一个方法，例如 `operator fun get (rowindex: Int, colindex:Int)`，然后用`matrix [row,col]`来调用。如果需要使用不同的键类型访问集合，也可以使用不同的参数类型定义多个重载的 `get` 方法。



也可以用类似的方式定义一个函数，这样就可以使用方括号语法更改给定下标处的值。`Point` 类是不可变的，所以定义 `Point` 的这种方法是没有意义的 。作为例子，来定义另一个类来表示一个可变的点。

```kotlin
data class MutablePoint(var x:Int,var y : Int)

// 定义一个名为set的运算符函数
operator fun MutablePoint.set(index:Int,value:Int){
    when(index){
        // 根据给出的index修改对应的坐标
        0-> x = value
        1-> y = value
        else ->
            throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}

fun main() {
    val p = MutablePoint(10,20)
    p[1] = 42
    println(p)
    // MutablePoint(x=10, y=42)
}
```

这个例子也很简单： 只需要定义一个名为 `set` 的函数，就可以在赋值语句中使用下标运算符。`set` 的最后一个参数用来接收赋值语句中（等号）右边的值，其他参数作为方括号内的下标。



## in的约定

集合支持的另一个运算符是`in`运算符，用于检查某个对象是否属于集合 。 相应的函数叫作 `contains` 。来实现一 下，使用 `in` 运算符来检查点是否属于一个矩形 。

```kotlin
data class Point(val x:Int,val y : Int)

data class Rectangle(val upperLeft:Point,val lowerRight:Point)

operator fun Rectangle.contains(p:Point):Boolean{
    // 构建一个区间，检查坐标x是否属于这个区间
    // 使用until函数来构建一个开区间
    return p.x in upperLeft.x until lowerRight.x &&
            p.y in upperLeft.y until  lowerRight.y
}


fun main() {
    val rect = Rectangle(Point(10,20),Point(50,50))
    println(Point(20,30) in rect)
    // true
    println(Point(5,5) in rect)
    // false
}
```

`in` 右边的对象将会调用 `contains` 函数，`in` 左边的对象将会作为函数入参 。



在 `Rectangle.contains` 的实现中用到了的标准库的 `until` 函数，来构建一个开区间，然后使用运算符 `in` 来检查某个点是否属于这个区间。



开区间是不包括最后一个点的区间。例如，如果用 `10..20` 构建一 个普通的区间（闭区间），该区间则包括 10 到 20 的所有数字 ，包括 20 。开区间 `10 until 20` 包括从 `10` 到`19`的数字，但不包括 20。矩形类通常定义成这样，它的底部和右侧坐标不是矩形的一部分，因此在这里使用开区间是合适的 。



## rangeTo的约定

要创建一个区间，需要使用 `..`语法：举个例子，`1..10` 代表所有从 1 到 10 的数字。来研究一 下创建它的约定。`..` 运算符是调用 `rangeTo` 函数的一个简洁方法。



`rangeTo` 函数返回 一个区间。可以为自己的类定义这个运算符。但是，如果该类实现了 `Comparable` 接口，那么不需要了： 可以通过 `Kotlin` 标准库创建一个任意可比较元素的区间，这个库定义了可以用 于任何可比较元素的 `rangeTo` 函数：

```kotlin
operator fun <T: Comparable<T>> T.rangeTo(that: T): ClosedRange<T>
```

这个函数返回 一个区间，可以用来检测其他一些元素是否属于它。



作为例子，用 `LocalDate` (`Java8` 标准库中有定义）来构建一个日期的区间 。

```kotlin
>>> val now = LocalDate.now()
// 创建一个从今天开始的10天的区间
>>> val vacation = now..now.plusDays(10)
// 检测一个特定的日期是否属于这个区间
>>> println(now.plusWeeks(1) in vacation)
true
```

`now..now.plusDays(10)`表达式将会被编译器转换为`now.rangeTo(now.plusDays(10))`。`rangeTo`并不是`LocalDate`的成员函数，而是`Comparable`的一个扩展函数。



`rangeTo` 运算符的优先级低于算术运算符，但是最好把参数括起来以免混淆：

```kotlin
>>> val n = 9
// 可以写成0..n+1,但括起来更清晰一点
>>> println(0..(n+1))
0..10
```

还要注意，表达式 `0..n. forEach{}`不会被编译，因为必须把区间表达式括起来才能调用它的方法：

```kotlin
// 把区间括起来，来调用它的方法
>>> (0..n).forEach{print(it)}
0123456789
```



## 在for循环中使用iterator的约定

在 `Kotlin` 中，`for` 循环中也可以使用 `in`运算符，和做区间检查一样。但是在这种情况下它的含义是不同的：它被用来执行迭代。这意味着一个诸如 `for(x in list){...}`将被转换成 `list.iterator()`的调用，然后就像在 `Java` 中一样，在它上面重复调用 `hasNext` 和 `next` 方法 。



请注意，在 `Kotlin` 中，这也是一种约定，这意味着 `iterator` 方法可以被定义为扩展函数。这就解释了为什么可以遍历一个常规的 `Java` 字符串：标准库已经为`CharSequence` 定义了一个扩展函数 `iterator` ，而它是 `String` 的父类：

```kotlin
// 这个库函数让迭代字符串成为可能
operator fun CharSequence.iterator(): CharIterator
>>> for(c in "abc"){}
```

