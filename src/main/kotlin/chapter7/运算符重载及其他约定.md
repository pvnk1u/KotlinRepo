`Java`在标准库中有一些与特定的类相关联的语言特性 。 例如，实现了`java.lang.Iterable` 接口的对象可以在 `for` 循环中使用，实现了 `java.lang.Aut oCloseable` 接口的对象可以在 `try-with-resources` 语句中使用 。



**`Kotlin` 也有许多特性的原理非常类似，通过调用自己代码中定义的函数，来实现特定语言结构 。 但是，在`Kotlin` 中，这些功能与特定的函数命名相关，而不是与特定的类型绑定 。 例如，如果在类中定义了一个名为 `plus` 的特殊方法，那么按照约定，就可以在该类的实例上使用＋运算符。因此，在 `Kotlin` 中，把这种技术称为约定 。** 



`Kotlin` 使用约定的原则，并不像 `Java` 那样依赖类型，因为它允许开发人员适应现有的 `Java` 类，来满足 `Kotlin` 语言特性的要求。由类实现的接口集是固定的，而`Kotlin` 不能为了实现其他接口而修改现有的类。另一方面，`Kotlin` 可以通过扩展函数的机制来为现有的类增添新的方法 。 可以把任意约定方法定义为扩展函数，从而适应任何现有的 `Java` 类而不用修改其代码。



作为这一章 的例子，将实现一个简单的 `Point` 类，用来表示屏幕上的 一个点。这样的类存在于大多数的 `UI` 框架中，也可以简单地把这里的定义用到自己的开发环境中去：

```kotlin
data class Point(val x:Int,val y:Int)
```



# 重载算术运算符

在 `Kotlin` 中使用约定的最直接的例子就是算术运算符 。在 `Java` 中，全套的算术运算只能用于基本数据类型，`+`运算符可以与 `String` 值一起使用。但是，这些运算在其他一些情况下用起来也很方便。例如，在使用 `BigInteger` 类处理数字的时候，使用`+`号就比调用 `add` 方法显得更为优雅：给集合添加元素的时候，可能也在想要是能用`+=`运算符就好了。在 `Kotlin` 中就可以这样做，在这一节就来看一下到底它是如何工作的。



## 重载二元算术运算

要支持的第一个运算，就是把两个点加到一起。这个运算需要把点的（X,Y)坐标分别加到一起。可以这样来实现：

```kotlin
data class PointPlus(val x:Int,val y:Int){

    // 定义一个名为plus的方法
    operator fun plus(other:PointPlus):PointPlus{
        // 坐标分别相加，然后返回一个新的点
        return PointPlus(x + other.x,y + other.y)
    }
}

fun main() {
    val p1 = PointPlus(10,20)
    val p2 = PointPlus(30,40)
    // 通过使用+号来调用plus方法
    println(p1 + p2)
    // PointPlus(x=40,y=60)
}
```

注意，**使用 `operator` 关键字来声明 `plus` 函数。用于重载运算符的所有函数都需要用该关键字标记，用来表示打算把这个函数作为相应的约定的实现，并且不是碰巧地定义一个同名函数。**



除了把这个运算符声明为一个成员函数外，也可以把它定义为一个扩展函数。

```kotlin
operator fun Point.plus(other: PointPlus): PointPlus{
	return PointPlus(x+other.x,y+other.y)
}
```

这样实现是一样的。后续的示例中将会使用扩展函数的语法来写，这是给第三方库的类定义约定扩展函数的常用模式。而且 ，对于自己的类这种语法也同样适用。



和其他一些语言相比 ， 在 `Kotlin` 中不管是定义还是使用重载运算符都更为简单 ，因为不能定义自己的运算符。`Kotlin` 限定了能重载哪些运算符 ，以及需要在自己的类中定义的对应名字的函数。下面的表列举了能定义的二元运算符 ，以及对应的函数名称 。

| 表达式 | 函数名 |
| ------ | ------ |
| a * b  | times  |
| a / b  | div    |
| a % b  | mod    |
| a + b  | plus   |
| a - b  | minus  |



**自定义类型的运算符，基本上和与标准数字类型的运算符有着相同的优先级。例如，如果是 `a+b *c` ，乘法将始终在添加之前执行，即使已经自己定义了这些运算符。运算符飞／和%具有相同的优先级，高于＋和 － 运算符的优先级。**



**当在定义一个运算符的时候 ，不要求两个运算数是相同的类型。**例如，来定义一个运算符，它允许用一个数字来缩放一个点，可以用它在不同坐标系之间做转换。

```kotlin
data class PointTimes(val x:Int,val y:Int){


}

operator fun PointTimes.times(scale: Double): PointTimes{
    return PointTimes((x * scale).toInt(),(y * scale).toInt())
}

fun main() {
    val p = PointTimes(10,20)
    println(p * 1.5)
    // PointTimes(x,15,y=30)
}
```

注意 ，`Kotlin` 运算符不会自动支持交换性 （交换运算符的左右两边）。如果希望用户能够使用 `1.5 * p` 以外，还能使用 `p * 1.5` ，需要为它定义一个单独的运算符： `operator fun Double.times(p : PointTimes): PointTimes` 。



运算符函数的返回类型也可以不同于任一运算数类型。例如，可以定义一个运算符，通过多次重复单个字符来创建字符串。

```kotlin
// 多次重复单个字符来创建字符串
operator fun Char.times(count: Int):String{
    return toString().repeat(count)
}

fun main() {
    println('a' * 3)
    // aaa
}
```

这个运算符，接收一个`Char`作为左值，`Int`作为右值，然后返回一个`String`类型。这样的运算数和结果类型的组合是允许的。



**注意，和普通的函数一样，可以重载`operator`函数：可以定义多个同名的，但参数类型不同的方法。**



## 重载复合赋值运算符



通常情况下，当在定义像`plus`这样的运算符函数时，`Kotlin`不止支持`+`号运算，也支持`+=`。像`+=`、`-=`等这些运算符被称为复合赋值运算符。看这个例子：

```kotlin
var point = PointPlus(1,2)
point += PointPlus(3,4)
println(point)
// PointPlus(x=4,y=6)
```

 这等同于`point = point + PointPlus(3,4)`的写法。当然 ，这个只对于可变变量有效。



在一些情况下，定义`+=`运算可以修改使用它的变量所引用的对象，但不会重新分配引用 。将一个元素添加到可变集合，就是一个很好的例子：

```kotlin
>>> val numbers = ArrayList<Int>()
>>> numbers += 42
>>> println(numbers[0])
42
```

如果定义了一个返回值为 `Unit` ，名为 `plusAssign` 的函数，`Kotlin` 将会在用到`+=`运算符的地方调用它。其他二元算术运算符也有命名相似的对应函数：如`minusAssign` 、`timesAssign` 等 。



`Kotlin` 标准库为可变集合定义 了 `plusAssign` 函数，在前面的例子中可以这样使用：

```kotlin
operator fun <T> MutableCollection<T>.plusAssign(element: T){
	this.add(element)
}
```

当在代码中用到`+=`的时候，理论上 `plus` 和 `plusAssign`都可能被调用。如果在这种情况下，两个函数都有定义且适用，编译器会报错 。一种可行的解决办法是，替换运算符的使用为普通函数调用。另一个办法是，用 `val` 替换 `var` ，这样 `plusAssign` 运算就不再适用。但一般来说，最好一致地设计出新的类：**尽量不要同时给一个类添加 `plus` 和 `plusAssign` 运算。如果像前面的一个示例中的 `Point` ，这个类是不可变的，那么就应该只提供返回 一个新值（如 `plus` ）的运算 。如果一个类是可变的，比如构建器，那么只需要提供 `plusAssign` 和类似的运算就够了。**



**`Kotlin` 标准库支持集合的这两种方法。`+`和 `-`运算符总是返回一个新的集合。`+=`和`-=`运算符用于可变集合时，始终在一个地方修改它们；而它们用于只读集合时 ，会返回一个修改过的副本。作为它们的运算数，可以使用单个元素，也可以使用元素类型一致的其他集合：**

```kotlin
>>> val list = arrayListOf(1,2)
>>> list += 3
>>> val newList = list + listOf(4,5)
>>> println(list)
[1,2,3]
>>> println(newList)
[1,2,3,4,5]
```



## 重载一元运算符

重载一元运算符的过程与在前面看到的方式相同：用预先定义的一个名称来声明函数（成员函数或扩展函数），并用修饰符 `operator`标记。

```kotlin
data class PointUnaryMinus(val x:Int,val y:Int){

}

// 一元运算符，无参数
operator fun PointUnaryMinus.unaryMinus(): PointUnaryMinus{
    // 坐标取反，然后返回
    return PointUnaryMinus(-x,-y)
}

fun main() {
    val p = PointUnaryMinus(10,20)
    println(-p)
    // PointUnaryMinus(x=-10, y=-20)
}
```

用于重载一元运算符的函数，没有任何参数。



可重载的一元算法的运算符：

| 表达式  | 函数名     |
| ------- | ---------- |
| +a      | unaryPlus  |
| -a      | unaryMinus |
| !a      | not        |
| ++a,a++ | inc        |
| --a,a-- | dec        |

当定义 `inc` 和 `dec` 函数来重载自增和自减的运算符时 ，编译器自动支持与普通数字类型的前缀和后缀自增运算符相同的语义 。考虑一下用来重载 `BigDecimal`类的`++`运算符的这个例子。

```kotlin
import java.math.BigDecimal

operator fun BigDecimal.inc() = this + BigDecimal.ONE

fun main() {
    var bd = BigDecimal.ZERO
    println(bd++)  //在println语句执行后增加
    // 0
    println(++bd)  // 在println语句执行前增加
    // 2
}
```

后缀运算`++`首先返回 `bd`变量的当前值，然后执行 `++` ，这个和前缀运算相反。打印的值与使用 `Int` 类型的变量所看到的相同 ， 不需要额外做什么特别的事情就能支持。



