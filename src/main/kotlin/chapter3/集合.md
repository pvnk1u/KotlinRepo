# 创建集合
```kotlin
fun main(args:Array<String>){
    // 创建set
    val set = hashSetOf(1,7,53)
    // 创建list
    val list = arrayListOf(1,7,53)
    // 创建map
    val map = hashMapOf(1 to "one",7 to "seven",53 to "fifty-three")

    // 打印结果
    println(set.javaClass)
    println(list.javaClass)
    println(map.javaClass)
    // 结果
    // class java.util.HashSet
    // class java.util.ArrayList
    // class java.util.HashMap

}
```

从打印结果来看,创建的类都是原本`Java`中就有的类,`Kotlin`没有自己专门的交互类,这是因为使用标准的`Java`集合类,`Kotlin`可以更容易的与`Java`代码交互。当从`Kotlin`中调用`Java`函数的时候,不用转换它的集合类来匹配`Java`的类,反之亦然。

尽管`Kotlin`的集合类和`Java`的集合类完全一致,但`Kotlin`还不止于此。例如,可以通过以下方式来获取一个列表中的最后一个元素,或者是得到一个数字列表的最大值:
```kotlin
fun main(args:Array<String>){
    // 创建set
    val strings = listOf("first","second","fourteenth")
    println(strings.last())
    // fourteenth
    // 创建set
    val numbers = setOf(1,14,2)
    println(numbers.max())
    // 14
}
```

# 让函数更好调用
`Java`的集合都有一个默认的`toString()`实现,但是它格式化的输出是固定的,而且往往不是你需要的样子:
```kotlin
fun main(args: Array<String>){
    val list = listOf(1,2,3)
    // 会调用默认的toString()
    println(list)
}
```

假设需要用分号来分隔每一个元素,然后用括号括起来,而不是采用默认实现用的方括号:(1;2;3)。要解决这个问题,`Java`项目会使用第三方的库,比如`Guava`和`Apache Commons`,或者是在这个项目中重写打印函数。在`Kotlin`中,它的标准库中有一个专门的函数来处理这种情况。

```kotlin
import java.lang.StringBuilder

fun <T> joinToString(
    collection: Collection<T>,
    separator: String,
    prefix: String,
    postfix: String
):String{
    val result = StringBuilder(prefix)
    for ((index,element) in collection.withIndex()){
        if (index > 0 ) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}

fun main(args: Array<String>){
    val list = listOf(1,2,3)
    println(joinToString(list,";","(",")"))
    // 打印结果 (1;2;3)
}
```
这个函数是泛型:它可以支持元素为任意类型的集合。这里泛型的语法和`Java`类似。


