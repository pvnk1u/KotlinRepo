
# 让函数更好调用
`Java`的集合都有一个默认的`toString()`实现,但是它格式化的输出是固定的,而且往往不是你需要的样子:
```kotlin
fun main(args: Array<String>){
    val list = listOf(1,2,3)
    // 会调用默认的toString()
    println(list)
}
```

假设需要用分号来分隔每一个元素,然后用括号括起来,而不是采用默认实现用的方括号:(1;2;3)。要解决这个问题,`Java`项目会使用第三方的库,比如`Guava`和`Apache Commons`,或者是在这个项目中重写打印函数。在`Kotlin`中,它的标准库中有一个专门的函数来处理这种情况。

```kotlin
import java.lang.StringBuilder

fun <T> joinToString(
    collection: Collection<T>,
    separator: String,
    prefix: String,
    postfix: String
):String{
    val result = StringBuilder(prefix)
    for ((index,element) in collection.withIndex()){
        if (index > 0 ) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}

fun main(args: Array<String>){
    val list = listOf(1,2,3)
    println(joinToString(list,";","(",")"))
    // 打印结果 (1;2;3)
}
```
这个函数是泛型:它可以支持元素为任意类型的集合。这里泛型的语法和`Java`类似。


## 默认参数值
`Java`一个普遍存在的问题是，一些类的重载函数实在太多了。在`Kotlin`中，可以在声明函数的时候，指定参数的默认值，这样就可以避免创建重载的函数。尝试改进一下前面的`joinToString`函数。在大多数情况下，字符串可以不加前缀或者后缀并用逗号分隔。所以把这些设置为默认值：
```kotlin
import java.lang.StringBuilder

fun <T> joinToStringWithDefaultPara(
    collection: Collection<T>,
    separator: String= ",",
    prefix: String = "",
    postfix: String = ""
):String{
    val result = StringBuilder(prefix)
    for ((index,element) in collection.withIndex()){
        if (index > 0 ) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}

fun main(args: Array<String>){
    val list = listOf(1,2,3)
    // 然后手动在调用时指定全部参数
    println(joinToStringWithDefaultPara(list,",","(",")"))
    // 在调用时只指定需要的参数，剩下的参数使用默认值
    println(joinToStringWithDefaultPara(list))
    println(joinToStringWithDefaultPara(list,";"))
}
```

## 默认值和Java
考虑到`Java`没有参数默认值的概念，当从`Java`中调用`Kotlin`函数的时候，必须显式地指定所有参数值。如果需要从`Java`代码中做频繁的调用，而且希望它能对`Java`的调用者更简便，可以用`@JvmOverloads`注解它。这个指示编译器生成`Java`重载函数，从最后一个开始省略每个参数。
举个例子，如果用`@JvmOverloads`注解了`joinToString`，编译器就会生成如下的重载函数:
```kotlin
String joinToString(Collection<T> collection,String separator,String prefix,String postfix);

String joinToString(Collection<T> collection,String separator,String prefiX);

String joinToString(Collection<T> collection,String separator);

String joinToString(Collection<T> collection);
```

## 消除静态工具类:顶层函数和属性
`Java`作为一门面向对象的语言，需要所有的代码都写作类的函数。大多数情况下，这种方式行得通。但事实上，几乎所有的大型项目，最终都有很多的代码并不能归属到任何一个类中。有时一个操作对应两个不同的类的对象，而且重要性相差无几。有时存在一个基本的对象，但是又不想通过实例函数来添加操作，让它的API继续膨胀。结果就是，最终这些类将不包含任何的状态或者实例函数，而是仅仅作为一堆静态函数的容器。

在`Kotlin`中，根本就不需要去创建这些无意义的类。相反，可以把这些函数直接放到代码文件的顶层，不用从属于任何的类。这些放在文件顶层的函数依然是包内的成员，如果需要从包外访问它，则需要import，但不再需要额外包一层。

把`joinToString`直接放到`strings`的包中试一下。依照下面这样：
```kotlin
package chapter3.strings

import java.lang.StringBuilder

fun <T> joinToStringWithKt(
    collection: Collection<T>,
    separator: String,
    prefix: String,
    postfix: String
):String{
    val result = StringBuilder(prefix)
    for ((index,element) in collection.withIndex()){
        if (index > 0 ) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
```

在其他包内调用时，可以通过这种方式调用：
```kotlin
package chapter3

import chapter3.strings.joinToStringWithKt

fun main(args: Array<String>){
    val list = listOf(1,2,3)
    // 然后手动在调用时指定全部参数
    println(joinToStringWithKt(list,",","(",")"))
}
```

# 给别人的类添加方法：扩展函数和属性
`Kotlin`的一大特色，就是可以平滑地与现有代码集成。甚至，纯`Kotlin`的项目都可以基于`Java`库构建，如`JDK`、`Android`框架，以及其他的第三方框架。当在一个现有的`Java`项目中集成`Kotlin`的时候，依然需要面临现有代码目前不能甚至以后也不能转成`Kotlin`的局面。当使用这些`API`的时候，如果不用重写，就能使用到`Kotlin`为它带来的方便，岂不是更好？这里，可以用扩展函数来实现。

理论上来说，扩展函数非常简单，它就是一个类的成员函数，不过定义在类的外面。